# Tank Battle Simulation Code

This document contains the code for the Tank Battle Simulation project.

## NetworkManager.h

```cpp
#pragma once

#include <winsock2.h>
#include <ws2tcpip.h>
#include <string>
#include <vector>
#include <functional>
#include <windows.h>
#include <process.h>

#pragma comment(lib, "ws2_32.lib")

// Maximum size of a UDP packet
#define MAX_PACKET_SIZE 1024

// Default port for the game
#define DEFAULT_PORT "27015"

// Network message types
enum class MessageType : uint8_t
{
    CONNECT_REQUEST = 1,
    CONNECT_ACCEPT = 2,
    DISCONNECT = 3,
    TANK_UPDATE = 4,
    BULLET_FIRED = 5,
    GAME_STATE = 6,
    CHAT_MESSAGE = 7,
    BULLET_HIT = 8,
    GAME_OVER = 9,
    GAME_RESET = 10
};

// Network message header
struct MessageHeader
{
    MessageType type;
    uint32_t size;
};

// Tank state for network transmission
struct NetworkTankState
{
    float x;
    float y;
    float z;
    float bodyRotation;
    float turretRotation;
    int health;
};

// Bullet state for network transmission
struct NetworkBulletState
{
    float x;
    float y;
    float z;
    float dirX;
    float dirY;
    float dirZ;
    int damage;
};

// Bullet hit notification for network transmission
struct NetworkBulletHit
{
    int damage;
    bool isPlayerHit; // true if the local player was hit, false if remote player was hit
};

// Game state for network transmission
struct NetworkGameState
{
    bool gameOver;
    bool playerWon; // true if local player won, false if remote player won
};

// Network manager class for handling UDP communication
class NetworkManager
{
public:
    // Initialize Winsock
    static bool Initialize();

    // Clean up Winsock
    static void Cleanup();

    NetworkManager();
    ~NetworkManager();

    // Start as server
    bool StartServer();

    // Start as client and connect to server
    bool ConnectToServer(const std::string &serverIP);

    // Send data to connected peer
    bool SendData(const void *data, int size);

    // Send a message with a specific type
    bool SendMessage(MessageType type, const void *data, int size);

    // Send a text message
    bool SendTextMessage(const std::string &message);

    // Send tank state
    bool SendTankState(const NetworkTankState &state);

    // Send bullet fired
    bool SendBulletFired(const NetworkBulletState &state);

    // Send bullet hit notification
    bool SendBulletHit(const NetworkBulletHit &hit);

    // Send game state update
    bool SendGameState(const NetworkGameState &state);

    // Send game reset request
    bool SendGameReset();

    // Process received data
    void ProcessReceivedData();

    // Check if connected
    bool IsConnected() const { return m_connected; }

    // Check if server
    bool IsServer() const { return m_isServer; }

    // Set callback for when a message is received
    void SetMessageCallback(std::function<void(MessageType, const void *, int)> callback)
    {
        m_messageCallback = callback;
    }

    // Set callback for when a connection is established
    void SetConnectCallback(std::function<void(bool)> callback)
    {
        m_connectCallback = callback;
    }

    // Set callback for when a connection is lost
    void SetDisconnectCallback(std::function<void()> callback)
    {
        m_disconnectCallback = callback;
    }

    // Get the IP address of the connected peer
    std::string GetPeerAddress() const { return m_peerAddress; }

private:
    // Socket for communication
    SOCKET m_socket;

    // Address of the peer
    sockaddr_in m_peerAddr;
    std::string m_peerAddress;

    // Thread for receiving data
    HANDLE m_receiveThread;
    bool m_running;

    // Connection state
    bool m_connected;
    bool m_isServer;

    // Buffer for receiving data
    char m_receiveBuffer[MAX_PACKET_SIZE];

    // Callbacks
    std::function<void(MessageType, const void *, int)> m_messageCallback;
    std::function<void(bool)> m_connectCallback;
    std::function<void()> m_disconnectCallback;

    // Receive data from socket
    void ReceiveThread();

    // Static thread function for _beginthreadex
    static unsigned int __stdcall ThreadProc(void *param);
};
```

## NetworkManager.cpp

```cpp
#include "NetworkManager.h"
#include <iostream>

// Initialize Winsock
bool NetworkManager::Initialize()
{
    WSADATA wsaData;
    int result = WSAStartup(MAKEWORD(2, 2), &wsaData);
    if (result != 0)
    {
        std::cerr << "WSAStartup failed: " << result << std::endl;
        return false;
    }
    return true;
}

// Clean up Winsock
void NetworkManager::Cleanup()
{
    WSACleanup();
}

NetworkManager::NetworkManager()
    : m_socket(INVALID_SOCKET),
      m_receiveThread(NULL),
      m_running(false),
      m_connected(false),
      m_isServer(false)
{
    memset(&m_peerAddr, 0, sizeof(m_peerAddr));
    memset(m_receiveBuffer, 0, MAX_PACKET_SIZE);
}

NetworkManager::~NetworkManager()
{
    // Stop the receive thread
    m_running = false;
    if (m_receiveThread != NULL)
    {
        WaitForSingleObject(m_receiveThread, 1000);
        CloseHandle(m_receiveThread);
        m_receiveThread = NULL;
    }

    // Close the socket
    if (m_socket != INVALID_SOCKET)
    {
        closesocket(m_socket);
        m_socket = INVALID_SOCKET;
    }
}

bool NetworkManager::StartServer()
{
    // Create a UDP socket
    m_socket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if (m_socket == INVALID_SOCKET)
    {
        std::cerr << "Error creating socket: " << WSAGetLastError() << std::endl;
        return false;
    }

    // Set up the server address
    sockaddr_in serverAddr;
    serverAddr.sin_family = AF_INET;
    serverAddr.sin_port = htons(atoi(DEFAULT_PORT));
    serverAddr.sin_addr.s_addr = INADDR_ANY;

    // Bind the socket
    if (bind(m_socket, (sockaddr *)&serverAddr, sizeof(serverAddr)) == SOCKET_ERROR)
    {
        std::cerr << "Bind failed: " << WSAGetLastError() << std::endl;
        closesocket(m_socket);
        m_socket = INVALID_SOCKET;
        return false;
    }

    // Set non-blocking mode
    u_long mode = 1;
    if (ioctlsocket(m_socket, FIONBIO, &mode) == SOCKET_ERROR)
    {
        std::cerr << "Failed to set non-blocking mode: " << WSAGetLastError() << std::endl;
        closesocket(m_socket);
        m_socket = INVALID_SOCKET;
        return false;
    }

    // Start the receive thread
    m_running = true;
    m_isServer = true;
    m_receiveThread = (HANDLE)_beginthreadex(NULL, 0, ThreadProc, this, 0, NULL);

    std::cout << "Server started on port " << DEFAULT_PORT << std::endl;
    return true;
}

bool NetworkManager::ConnectToServer(const std::string &serverIP)
{
    // Log connection attempt
    std::cout << "Network Manager: Connecting to server at " << serverIP << std::endl;

    // Create a UDP socket
    m_socket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if (m_socket == INVALID_SOCKET)
    {
        std::cerr << "Error creating socket: " << WSAGetLastError() << std::endl;
        return false;
    }

    // Set up the server address
    m_peerAddr.sin_family = AF_INET;
    m_peerAddr.sin_port = htons(atoi(DEFAULT_PORT));

    // Clean the IP address string to ensure it's valid
    std::string cleanedIP;

    // First, check if the IP is already valid
    bool isValid = true;
    for (char c : serverIP)
    {
        if (!((c >= '0' && c <= '9') || c == '.'))
        {
            isValid = false;
            break;
        }
    }

    if (isValid)
    {
        // IP is already valid, use as is
        cleanedIP = serverIP;
    }
    else
    {
        // IP needs cleaning, extract only digits and dots
        for (char c : serverIP)
        {
            // Only keep digits and dots for IP address
            if ((c >= '0' && c <= '9') || c == '.')
            {
                cleanedIP += c;
            }
            else if (c == ',')
            {
                // Replace commas with dots (common typo)
                cleanedIP += '.';
            }
        }
    }

    // Special case for localhost
    if (serverIP == "localhost" || serverIP == "LOCALHOST")
    {
        cleanedIP = "127.0.0.1";
    }

    // Convert IP address string to network address
    unsigned long addr = inet_addr(cleanedIP.c_str());
    if (addr == INADDR_NONE)
    {
        std::cerr << "Invalid IP address format: " << cleanedIP << std::endl;
        closesocket(m_socket);
        m_socket = INVALID_SOCKET;
        return false;
    }

    m_peerAddr.sin_addr.s_addr = addr;
    m_peerAddress = cleanedIP; // Store the cleaned IP

    // Set non-blocking mode
    u_long mode = 1;
    if (ioctlsocket(m_socket, FIONBIO, &mode) == SOCKET_ERROR)
    {
        std::cerr << "Failed to set non-blocking mode: " << WSAGetLastError() << std::endl;
        closesocket(m_socket);
        m_socket = INVALID_SOCKET;
        return false;
    }

    // Send a connection request
    MessageHeader header;
    header.type = MessageType::CONNECT_REQUEST;
    header.size = sizeof(MessageHeader);

    if (sendto(m_socket, (const char *)&header, sizeof(header), 0,
               (sockaddr *)&m_peerAddr, sizeof(m_peerAddr)) == SOCKET_ERROR)
    {
        std::cerr << "Failed to send connection request: " << WSAGetLastError() << std::endl;
        closesocket(m_socket);
        m_socket = INVALID_SOCKET;
        return false;
    }

    // Start the receive thread
    m_running = true;
    m_isServer = false;
    m_receiveThread = (HANDLE)_beginthreadex(NULL, 0, ThreadProc, this, 0, NULL);

    std::cout << "Connecting to server at " << serverIP << ":" << DEFAULT_PORT << std::endl;
    return true;
}

bool NetworkManager::SendData(const void *data, int size)
{
    if (!m_connected)
    {
        std::cerr << "Not connected to a peer" << std::endl;
        return false;
    }

    if (sendto(m_socket, (const char *)data, size, 0,
               (sockaddr *)&m_peerAddr, sizeof(m_peerAddr)) == SOCKET_ERROR)
    {
        std::cerr << "Failed to send data: " << WSAGetLastError() << std::endl;
        return false;
    }

    return true;
}

bool NetworkManager::SendMessage(MessageType type, const void *data, int size)
{
    // Create a buffer for the message
    std::vector<char> buffer(sizeof(MessageHeader) + size);
    MessageHeader *header = (MessageHeader *)buffer.data();
    header->type = type;
    header->size = sizeof(MessageHeader) + size;

    // Copy the data after the header
    if (size > 0 && data != nullptr)
    {
        memcpy(buffer.data() + sizeof(MessageHeader), data, size);
    }

    // Send the message
    return SendData(buffer.data(), buffer.size());
}

bool NetworkManager::SendTextMessage(const std::string &message)
{
    return SendMessage(MessageType::CHAT_MESSAGE, message.c_str(), message.length() + 1);
}

bool NetworkManager::SendTankState(const NetworkTankState &state)
{
    return SendMessage(MessageType::TANK_UPDATE, &state, sizeof(state));
}

bool NetworkManager::SendBulletFired(const NetworkBulletState &state)
{
    return SendMessage(MessageType::BULLET_FIRED, &state, sizeof(state));
}

bool NetworkManager::SendBulletHit(const NetworkBulletHit &hit)
{
    return SendMessage(MessageType::BULLET_HIT, &hit, sizeof(hit));
}

bool NetworkManager::SendGameState(const NetworkGameState &state)
{
    return SendMessage(MessageType::GAME_STATE, &state, sizeof(state));
}

bool NetworkManager::SendGameReset()
{
    return SendMessage(MessageType::GAME_RESET, nullptr, 0);
}

// Static thread function
unsigned int __stdcall NetworkManager::ThreadProc(void *param)
{
    NetworkManager *self = static_cast<NetworkManager *>(param);
    self->ReceiveThread();
    return 0;
}

void NetworkManager::ReceiveThread()
{
    while (m_running)
    {
        // Receive data
        sockaddr_in senderAddr;
        int senderAddrSize = sizeof(senderAddr);
        int bytesReceived = recvfrom(m_socket, m_receiveBuffer, MAX_PACKET_SIZE, 0,
                                     (sockaddr *)&senderAddr, &senderAddrSize);

        if (bytesReceived > 0)
        {
            // Process the received data
            MessageHeader *header = (MessageHeader *)m_receiveBuffer;

            // Handle connection messages
            if (header->type == MessageType::CONNECT_REQUEST)
            {
                if (m_isServer && !m_connected)
                {
                    // Store the client's address
                    memcpy(&m_peerAddr, &senderAddr, sizeof(senderAddr));

                    // Get the client's IP address as a string
                    char *ipStr = inet_ntoa(senderAddr.sin_addr);
                    m_peerAddress = ipStr;

                    // Send connection accept
                    MessageHeader response;
                    response.type = MessageType::CONNECT_ACCEPT;
                    response.size = sizeof(MessageHeader);

                    sendto(m_socket, (const char *)&response, sizeof(response), 0,
                           (sockaddr *)&m_peerAddr, sizeof(m_peerAddr));

                    // Set connected state
                    m_connected = true;

                    // Call the connect callback
                    if (m_connectCallback)
                    {
                        m_connectCallback(true);
                    }

                    std::cout << "Client connected from " << m_peerAddress << std::endl;
                }
            }
            else if (header->type == MessageType::CONNECT_ACCEPT)
            {
                if (!m_isServer && !m_connected)
                {
                    // Set connected state
                    m_connected = true;

                    // Call the connect callback
                    if (m_connectCallback)
                    {
                        m_connectCallback(true);
                    }

                    std::cout << "Connected to server" << std::endl;
                }
            }
            else if (header->type == MessageType::DISCONNECT)
            {
                // Handle disconnect
                m_connected = false;

                // Call the disconnect callback
                if (m_disconnectCallback)
                {
                    m_disconnectCallback();
                }

                std::cout << "Disconnected from peer" << std::endl;
            }
            else if (m_connected)
            {
                // Call the message callback for other message types
                if (m_messageCallback)
                {
                    m_messageCallback(header->type,
                                      m_receiveBuffer + sizeof(MessageHeader),
                                      bytesReceived - sizeof(MessageHeader));
                }
            }
        }
        else if (bytesReceived == SOCKET_ERROR)
        {
            int error = WSAGetLastError();
            if (error != WSAEWOULDBLOCK)
            {
                std::cerr << "Error receiving data: " << error << std::endl;

                // Handle disconnection
                if (m_connected)
                {
                    m_connected = false;

                    // Call the disconnect callback
                    if (m_disconnectCallback)
                    {
                        m_disconnectCallback();
                    }

                    std::cout << "Connection lost" << std::endl;
                }
            }
        }

        // Sleep to avoid high CPU usage
        Sleep(10);
    }
}
```

## EnhancedTankGame.cpp (Game Over Screen Implementation)

```cpp
// Draw game over screen
void DrawGameOverScreen()
{
    if (!showGameOverScreen)
        return;

    // Switch to 2D orthographic projection
    glDisable(GL_LIGHTING);
    glDisable(GL_DEPTH_TEST);

    glMatrixMode(GL_PROJECTION);
    glPushMatrix();
    glLoadIdentity();
    // Fix the mirrored text by using a standard orthographic projection
    glOrtho(0, currentWidth, 0, currentHeight, -1, 1);

    glMatrixMode(GL_MODELVIEW);
    glPushMatrix();
    glLoadIdentity();

    // Draw semi-transparent background with border
    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

    // Calculate menu dimensions - centered with proper proportions
    float menuWidth = currentWidth * 0.6f;
    float menuHeight = currentHeight * 0.4f;
    float menuLeft = (currentWidth - menuWidth) / 2.0f;
    float menuRight = menuLeft + menuWidth;
    float menuBottom = (currentHeight - menuHeight) / 2.0f;
    float menuTop = menuBottom + menuHeight;

    // Calculate the vertical center of the menu for better positioning
    float menuCenterY = menuBottom + (menuHeight / 2.0f);

    // Calculate retry button dimensions first (we'll draw it later)
    float buttonWidth = 200.0f;
    float buttonHeight = 50.0f; // Slightly taller button for better visibility
    float buttonLeft = menuCenterX - (buttonWidth / 2.0f);
    float buttonRight = buttonLeft + buttonWidth;
    // Position the button with proper spacing from the top text
    float buttonBottom = menuCenterY - (buttonHeight / 2.0f); // Center vertically in the lower half
    float buttonTop = buttonBottom + buttonHeight;

    // Draw semi-transparent dark background
    glColor4f(0.0f, 0.0f, 0.1f, 0.9f);
    glBegin(GL_QUADS);
    glVertex2f(menuLeft, menuBottom);
    glVertex2f(menuRight, menuBottom);
    glVertex2f(menuRight, menuTop);
    glVertex2f(menuLeft, menuTop);
    glEnd();

    // Draw border
    glColor4f(1.0f, 1.0f, 0.0f, 1.0f);
    glLineWidth(4.0f);
    glBegin(GL_LINE_LOOP);
    glVertex2f(menuLeft, menuBottom);
    glVertex2f(menuRight, menuBottom);
    glVertex2f(menuRight, menuTop);
    glVertex2f(menuLeft, menuTop);
    glEnd();

    // Draw inner border
    glColor4f(1.0f, 1.0f, 0.0f, 0.7f);
    glLineWidth(2.0f);
    glBegin(GL_LINE_LOOP);
    glVertex2f(menuLeft + 8, menuBottom + 8);
    glVertex2f(menuRight - 8, menuBottom + 8);
    glVertex2f(menuRight - 8, menuTop - 8);
    glVertex2f(menuLeft + 8, menuTop - 8);
    glEnd();

    // Calculate menu center for alignment
    float menuCenterX = menuLeft + (menuWidth / 2.0f);

    // Store button position for mouse click detection
    static float retryButtonLeft = buttonLeft;
    static float retryButtonRight = buttonRight;
    static float retryButtonBottom = buttonBottom;
    static float retryButtonTop = buttonTop;

    // Draw retry button background first (so it's behind everything)
    if (showRetryButton)
    {
        // Draw button background
        glColor4f(0.2f, 0.2f, 0.3f, 0.9f);
        glBegin(GL_QUADS);
        glVertex2f(buttonLeft, buttonBottom);
        glVertex2f(buttonRight, buttonBottom);
        glVertex2f(buttonRight, buttonTop);
        glVertex2f(buttonLeft, buttonTop);
        glEnd();

        // Draw button border
        glColor4f(1.0f, 1.0f, 0.0f, 1.0f);
        glLineWidth(2.0f);
        glBegin(GL_LINE_LOOP);
        glVertex2f(buttonLeft, buttonBottom);
        glVertex2f(buttonRight, buttonBottom);
        glVertex2f(buttonRight, buttonTop);
        glVertex2f(buttonLeft, buttonTop);
        glEnd();
    }

    // Draw result message as the main title
    std::string resultMessage = playerWon ? "YOU WIN" : "YOU LOSE";
    DrawRetroText(menuCenterX, menuTop - 40, resultMessage, true, true, playerWon);

    // Draw horizontal separator below title
    glColor4f(1.0f, 1.0f, 0.0f, 0.7f);
    glLineWidth(2.0f);
    glBegin(GL_LINES);
    glVertex2f(menuLeft + 20, menuTop - 60);
    glVertex2f(menuRight - 20, menuTop - 60);
    glEnd();

    // Draw health status - position between the title and the button
    std::string playerHealthMsg = "YOUR HEALTH: " + std::to_string(playerTank.health) + "/" + std::to_string(playerTank.maxHealth);
    DrawRetroText(menuCenterX, menuTop - 120, playerHealthMsg, true);

    std::string remoteHealthMsg = "ENEMY HEALTH: " + std::to_string(remoteTank.health) + "/" + std::to_string(remoteTank.maxHealth);
    DrawRetroText(menuCenterX, menuTop - 160, remoteHealthMsg, true);

    // Draw retry button text last (so it's on top of everything)
    if (showRetryButton)
    {
        // Use a higher z-order for the button text by temporarily adjusting the depth range
        glDepthRange(0.0, 0.1); // Bring text closer to viewer

        // Draw button text with enhanced visibility
        // First draw a larger outline for better visibility
        glColor3f(0.0f, 0.0f, 0.0f);
        for (int dx = -3; dx <= 3; dx++)
        {
            for (int dy = -3; dy <= 3; dy++)
            {
                if ((abs(dx) == 3 || abs(dy) == 3) && !(abs(dx) == 3 && abs(dy) == 3))
                {
                    DrawSimpleText(menuCenterX - (5 * 11.0f) + dx, buttonBottom + 15 + dy, "RETRY", 0.0f, 0.0f, 0.0f);
                }
            }
        }

        // Draw white glow around text
        glColor3f(1.0f, 1.0f, 1.0f);
        for (int dx = -2; dx <= 2; dx++)
        {
            for (int dy = -2; dy <= 2; dy++)
            {
                if ((abs(dx) == 2 || abs(dy) == 2) && !(abs(dx) == 2 && abs(dy) == 2))
                {
                    DrawSimpleText(menuCenterX - (5 * 11.0f) + dx, buttonBottom + 15 + dy, "RETRY", 1.0f, 1.0f, 1.0f);
                }
            }
        }

        // Draw the actual text in bright yellow
        DrawSimpleText(menuCenterX - (5 * 11.0f), buttonBottom + 15, "RETRY", 1.0f, 1.0f, 0.0f);

        // Add a pulsing effect to make the button more noticeable
        static float pulseTime = 0.0f;
        pulseTime += deltaTime;
        float pulseScale = 1.0f + 0.1f * sin(pulseTime * 5.0f);

        // Draw an additional highlight around the button
        glColor4f(1.0f, 1.0f, 0.0f, 0.3f + 0.2f * sin(pulseTime * 5.0f));
        glLineWidth(3.0f * pulseScale);
        glBegin(GL_LINE_LOOP);
        glVertex2f(buttonLeft - 5, buttonBottom - 5);
        glVertex2f(buttonRight + 5, buttonBottom - 5);
        glVertex2f(buttonRight + 5, buttonTop + 5);
        glVertex2f(buttonLeft - 5, buttonTop + 5);
        glEnd();

        // Reset depth range
        glDepthRange(0.0, 1.0);

        // Check if mouse is clicked on the retry button
        if (GetAsyncKeyState(VK_LBUTTON) & 0x8000)
        {
            POINT mousePos;
            GetCursorPos(&mousePos);
            ScreenToClient(hWnd, &mousePos);

            // Convert to OpenGL coordinates (y is inverted)
            float mouseX = static_cast<float>(mousePos.x);
            float mouseY = currentHeight - static_cast<float>(mousePos.y);

            if (mouseX >= retryButtonLeft && mouseX <= retryButtonRight &&
                mouseY >= retryButtonBottom && mouseY <= retryButtonTop)
            {
                // Reset the game
                ResetGame();

                // Send game reset message to remote player
                if (isNetworked && networkManager.IsConnected())
                {
                    networkManager.SendGameReset();
                }
            }
        }
    }

    // Restore 3D projection
    glMatrixMode(GL_PROJECTION);
    glPopMatrix();
    glMatrixMode(GL_MODELVIEW);
    glPopMatrix();

    glEnable(GL_DEPTH_TEST);
    glEnable(GL_LIGHTING);
}
```
